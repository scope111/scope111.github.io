<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/18/Java集合/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="scope">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/18/Java集合/" itemprop="url">Java集合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-18T22:13:06+08:00">
                2019-07-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1接口继承关系和实现"><a href="#1接口继承关系和实现" class="headerlink" title="1接口继承关系和实现"></a>1接口继承关系和实现</h1><p>集合类存放于 Java.util 包中，主要有 3 种：set(集）、list(列表包含 Queue）和 map(映射)</p>
<ol>
<li>Collection：Collection 是集合 List、Set、Queue 的最基本的接口。</li>
<li>Iterator：迭代器，可以通过迭代器遍历集合中的数据</li>
<li>Map：是映射表的基础接口<img src="https://img-blog.csdnimg.cn/20190404111809377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Njb3BlMTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h1 id="2List"><a href="#2List" class="headerlink" title="2List"></a>2List</h1><h2 id="2-1-ArrayList（数组）"><a href="#2-1-ArrayList（数组）" class="headerlink" title="2.1 ArrayList（数组）"></a>2.1 ArrayList（数组）</h2>ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，==它适合随机查找和遍历==，==不适合插入和删除==。<h2 id="2-2-Vector（数组实现、线程同步）"><a href="#2-2-Vector（数组实现、线程同步）" class="headerlink" title="2.2.Vector（数组实现、线程同步）"></a>2.2.Vector（数组实现、线程同步）</h2>Vector 与 ArrayList 一样，也是通过数组实现的，不同的是它==支持线程的同步==，即某一时刻只有一个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问 ArrayList 慢。<h2 id="2-3-LinkList（链表）"><a href="#2-3-LinkList（链表）" class="headerlink" title="2.3. LinkList（链表）"></a>2.3. LinkList（链表）</h2>LinkedList 是用==链表结构==存储数据的，很适合数据的==动态插入和删除==，==随机访问和遍历速度比较慢==。另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，==可以当作堆栈、队列和双向队列使用==。<h1 id="3-Set"><a href="#3-Set" class="headerlink" title="3 Set"></a>3 Set</h1>Set 注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。==对象的相等性本质是对象 hashCode 值==（java 是依据对象的内存地址计算出的此序号）判断的，==如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方法==。<h2 id="3-1-HashSet（Hash-表）"><a href="#3-1-HashSet（Hash-表）" class="headerlink" title="3.1 HashSet（Hash 表）"></a>3.1 HashSet（Hash 表）</h2>哈希表边存放的是哈希值。HashSet ==存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得==。元素的哈希值是通过元素的hashcode 方法来获取的, HashSet 首先判断两个元素的哈希值，==如果哈希值一样，接着会比较equals 方法 如果 equls 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素==。<br>哈希值相同 equals 为 false 的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。如图 1 表示 hashCode 值不相同的情况；图 2 表示 hashCode 值相同，但 equals 不相同的情况。<br><img src="https://img-blog.csdnimg.cn/20190404112841294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Njb3BlMTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="3-2TreeSet（二叉树）"><a href="#3-2TreeSet（二叉树）" class="headerlink" title="3.2TreeSet（二叉树）"></a>3.2TreeSet（二叉树）</h2></li>
<li>TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。</li>
<li>Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的，自己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数，才可以正常使用。</li>
<li>在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序</li>
<li>比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整<br>数、零或正整数。<h2 id="3-3-LinkHashSet（HashSet-LinkedHashMap）"><a href="#3-3-LinkHashSet（HashSet-LinkedHashMap）" class="headerlink" title="3.3 LinkHashSet（HashSet+LinkedHashMap）"></a>3.3 LinkHashSet（HashSet+LinkedHashMap）</h2>对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/18/JVM类加载机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="scope">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/18/JVM类加载机制/" itemprop="url">JVM类加载机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-18T22:12:12+08:00">
                2019-07-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="10-JVM类加载机制"><a href="#10-JVM类加载机制" class="headerlink" title="10 JVM类加载机制"></a>10 JVM类加载机制</h1><h2 id="10-1类加载机制"><a href="#10-1类加载机制" class="headerlink" title="10.1类加载机制"></a>10.1类加载机制</h2><p>JVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化。<br><img src="https://img-blog.csdnimg.cn/20190402095641470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Njb3BlMTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="10-1-1加载"><a href="#10-1-1加载" class="headerlink" title="10.1.1加载"></a>10.1.1加载</h3><p>这个阶段会在==内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的入口==。</p>
<h3 id="10-1-2-验证"><a href="#10-1-2-验证" class="headerlink" title="10.1.2.验证"></a>10.1.2.验证</h3><p>这一阶段的主要目的是为了==确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求==，并且不会危害虚拟机自身的安全。</p>
<h3 id="10-1-3准备"><a href="#10-1-3准备" class="headerlink" title="10.1.3准备"></a>10.1.3准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为：<br>public static int v = 8080;<br>实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080，将 v 赋值为 8080 的 put static 指令是程序被编译后，==存放于类构造器<client>方法之中==<br>但是注意如果声明为：public static final int v = 8080;<br>在编译阶段会为 v 生成   ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v赋值为 8080。</client></p>
<h3 id="10-1-4-解析"><a href="#10-1-4-解析" class="headerlink" title="10.1.4.解析"></a>10.1.4.解析</h3><p>解析阶段是指虚拟机将常量池中的符号引用（==符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的==，因为符号引用的字面量形式明确定义在Java 虚拟机规范的 Class 文件格式中）替换为直接引用（直接引用可以是==指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。==）的过程。符号引用就是 class 文件中的：<br> CONSTANT_Class_info、CONSTANT_Field_info、CONSTANT_Method_info等类型的常量。</p>
<h3 id="10-1-5-初始化"><a href="#10-1-5-初始化" class="headerlink" title="10.1.5.初始化"></a>10.1.5.初始化</h3><p>初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。</p>
<h3 id="10-1-6-类构造器"><a href="#10-1-6-类构造器" class="headerlink" title="10.1.6.类构造器"></a>10.1.6.类构造器<client></client></h3><p>初始化阶段是执行类构造器<client>方法的过程。<client>方法是==由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的==。虚拟机会保证子<client>方法执行之前，父类的<client>方法已经执行完毕，如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<client>()方法。</client></client></client></client></client></p>
<h2 id="10-2-类加载器"><a href="#10-2-类加载器" class="headerlink" title="10.2.类加载器"></a>10.2.类加载器</h2><p>虚拟机设计团队把加载动作放到 JVM 外部实现，以便让应用程序决定如何获取所需的类，JVM 提供了 3 种类加载器：<br>1.启动类加载器(Bootstrap ClassLoader)<br>负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath 参数指定路径中的，且被虚拟机认可（按文件名识别，如 rt.jar）的类。<br>2.扩展类加载器(Extension ClassLoader)<br> 负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类库。</p>
<ol start="3">
<li>应用程序类加载器(Application ClassLoader)：</li>
<li>负责加载用户路径（classpath）上的类库。<br>JVM 通过双亲委派模型进行类的加载，当然我们也可以通过继承 java.lang.ClassLoader实现自定义的类加载器。<h2 id="10-3-双亲委派"><a href="#10-3-双亲委派" class="headerlink" title="10.3.双亲委派"></a>10.3.双亲委派</h2>==当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此==，因此所有的加载请求都应该传送到启动类加载其中，==只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载==。<br>采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就==保证了使用不同的类加载器最终得到的都是同样一个 Object 对象==。<br><img src="https://img-blog.csdnimg.cn/20190402101542816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Njb3BlMTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="10-4-OSGI（动态模型系统）"><a href="#10-4-OSGI（动态模型系统）" class="headerlink" title="10.4. OSGI（动态模型系统）"></a>10.4. OSGI（动态模型系统）</h2>OSGi(Open Service Gateway Initiative)，是面向 Java 的动态模型系统，是 Java 动态化模块化系统的一系列规范。<h3 id="10-4-1-动态改变构造"><a href="#10-4-1-动态改变构造" class="headerlink" title="10.4.1. 动态改变构造"></a>10.4.1. 动态改变构造</h3>OSGi 服务平台提供在多种网络设备上无需重启的动态改变构造的功能。为了最小化耦合度和促使这些耦合度可管理，OSGi 技术提供一种面向服务的架构，它能使这些组件动态地发现对方。<h3 id="10-4-2-模块化编程与热插拔"><a href="#10-4-2-模块化编程与热插拔" class="headerlink" title="10.4.2. 模块化编程与热插拔"></a>10.4.2. 模块化编程与热插拔</h3>OSGi 旨在为实现 Java 程序的模块化编程提供基础条件，基于 OSGi 的程序很可能可以实现模块级的热插拔功能，当程序升级更新时，可以只停用、重新安装然后启动程序的其中一部分，这对企业级程序开发来说是非常具有诱惑力的特性。<br>OSGi 描绘了一个很美好的模块化开发目标，而且定义了实现这个目标的所需要服务与架构，同时也有成熟的框架进行实现支持。但并非所有的应用都适合采用 OSGi 作为基础架构，它在提供强大功能同时，也引入了额外的复杂度，因为它不遵守了类加载的双亲委托模型。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/18/JAVA-IO-NIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="scope">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/18/JAVA-IO-NIO/" itemprop="url">Java IO/NIO</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-18T22:11:42+08:00">
                2019-07-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="9JAVA-IO-NIO"><a href="#9JAVA-IO-NIO" class="headerlink" title="9JAVA IO/NIO"></a>9JAVA IO/NIO</h1><h2 id="9-1阻塞-IO-模型"><a href="#9-1阻塞-IO-模型" class="headerlink" title="9.1阻塞 IO 模型"></a>9.1阻塞 IO 模型</h2><p>最传统的一种 IO 模型，即在==读写数据过程中会发生阻塞==现象。当用户线程发出 IO 请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出 CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除 block 状态。典型的阻塞 IO 模型的例子为：==data = socket.read()==;如果数据没有就绪，就会一直阻塞在 read 方法。</p>
<h2 id="9-2非阻塞-IO-模型"><a href="#9-2非阻塞-IO-模型" class="headerlink" title="9.2非阻塞 IO 模型"></a>9.2非阻塞 IO 模型</h2><p>当用户线程发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。所以事实上，在非阻塞 IO 模型中，==用户线程需要不断地询问内核数据是否就绪==，也就说非阻塞 IO不会交出 CPU，而会一直占用 CPU。典型的非阻塞 IO 模型一般如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while(true)&#123;</span><br><span class="line">data = socket.read();</span><br><span class="line">if(data!= error)&#123;</span><br><span class="line">处理数据</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非阻塞 IO 就有一个==非常严重的问题，在 while 循环中需要不断地去询问内核数据是否就绪，这样会导致 CPU 占用率非常高==，因此一般情况下==很少==使用 while 循环这种方式来读取数据。</p>
<h2 id="9-3-多路复用-IO-模型"><a href="#9-3-多路复用-IO-模型" class="headerlink" title="9.3 多路复用 IO 模型"></a>9.3 多路复用 IO 模型</h2><p>多路复用 IO 模型是目前使用得比较多的模型。==Java NIO 实际上就是多路复用 IO==。在多路复用 IO模型中，会有一个线程==不断去轮询多个 socket 的状态==，只有当== socket 真正有读写事件时，才真正调用实际的 IO 读写操作==。<br>多路复用 IO 模型中，只需要使用一个线程就可以管理多个socket，在真正有socket 读写事件进行时，才会使用 IO 资源，所以它大大减少了资源占用。适合连接数比较多的情况。<br>==另外多路复用 IO 为何比非阻塞 IO 模型的效率高是因为在非阻塞 IO 中，不断地询问 socket 状态时通过用户线程去进行的，而在多路复用 IO 中，轮询每个 socket 状态是内核在进行的，这个效率要比用户线程要高的多==<br>==多路复用 IO 模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用 IO 模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询==</p>
<h2 id="9-4-信号驱动-IO-模型"><a href="#9-4-信号驱动-IO-模型" class="headerlink" title="9.4 信号驱动 IO 模型"></a>9.4 信号驱动 IO 模型</h2><p>在信号驱动 IO 模型中，当用户线程发起一个 IO 请求操作，会给对应的 socket 注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作。</p>
<h2 id="9-5-异步-IO-模型"><a href="#9-5-异步-IO-模型" class="headerlink" title="9.5 异步 IO 模型"></a>9.5 异步 IO 模型</h2><p>异步 IO 模型才是最理想的 IO 模型，在异步 IO 模型中，当用户线程发起 read 操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个 asynchronous read 之后，它会立刻返回，说明 read 请求已经成功发起了，因此不会对用户线程产生任何 block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它 read 操作完成了。也就说用户线程完全不需要实际的整个 IO 操作是如何进行的，==只需要先发起一个请求，当接收内核返回的成功信号时表示 IO 操作已经完成，可以直接去使用数据了。==    ==全在内核中处理==<br>注意，异步 IO 是==需要操作系统的底层支持==，在 Java 7 中，提供了 Asynchronous IO</p>
<h2 id="9-6-JAVA-IO-包"><a href="#9-6-JAVA-IO-包" class="headerlink" title="9.6 JAVA IO 包"></a>9.6 JAVA IO 包</h2><h3 id="9-6-1-JAVA-NIO"><a href="#9-6-1-JAVA-NIO" class="headerlink" title="9.6.1 JAVA NIO"></a>9.6.1 JAVA NIO</h3><p>NIO 主要有三大核心部分：==Channel(通道)==，==Buffer(缓冲区)== ，==Selector==。传统 IO 基于字节流和字符流进行操作，而 NIO 基于 Channel 和 Buffer(缓冲区)进行操作，==数据总是从通道读取到缓冲区中==，==或者从缓冲区写入到通道中==。Selector(选择区)用于==监听多个通道的事件==（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。<br>NIO 和传统 IO 之间第一个最大的区别是，==IO 是面向流的，NIO 是面向缓冲区的==。</p>
<h4 id="9-6-1-1NIO-的缓冲区"><a href="#9-6-1-1NIO-的缓冲区" class="headerlink" title="9.6.1.1NIO 的缓冲区"></a>9.6.1.1NIO 的缓冲区</h4><p>Java IO 面向流意味着每次从流中读一个或多个字节，直至读取所有字节，==它们没有被缓存在任何地方==。此外，==它不能前后移动流中的数据==。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。NIO 的缓冲导向方法不同。数据读取到一个它稍后处理的缓冲区，==需要时可在缓冲区中前后移动==。这就增加了处理过程中的灵活性。</p>
<h4 id="9-6-1-2NIO-的非阻塞"><a href="#9-6-1-2NIO-的非阻塞" class="headerlink" title="9.6.1.2NIO 的非阻塞"></a>9.6.1.2NIO 的非阻塞</h4><p>IO 的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO 的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用于在其它通道上执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>
<h3 id="9-6-2Channel"><a href="#9-6-2Channel" class="headerlink" title="9.6.2Channel"></a>9.6.2Channel</h3><p>Channel 和 IO 中的 Stream(流)是差不多一个等级的。只不过 Stream 是==单向==的，譬如：InputStream, OutputStream，而 Channel 是==双向==的，既可以用来进行读操作，又可以用来进行写操作。<br>NIO 中的 Channel 的主要实现有：</p>
<ol>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel<br>分别可以对应文件 IO、UDP 和 TCP（Server 和 Client）<h3 id="9-6-3-Buffer"><a href="#9-6-3-Buffer" class="headerlink" title="9.6.3 Buffer"></a>9.6.3 Buffer</h3>缓冲区，实际上是一个容器，是一个连续数组。Channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer。<br><img src="https://img-blog.csdnimg.cn/20190402094850343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Njb3BlMTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>一个客户端向服务端发送数据，然后服务端接收数据的过程。客户端发送数据时，必须先将数据存入 Buffer 中，然后将 Buffer 中的内容写入通道。服务端这边接收数据必须通过 Channel 将数据读入到 Buffer 中，然后再从 Buffer 中取出数据来处理。<br>在 NIO 中，Buffer 是一个顶层父类，它是一个抽象类。常用的 Buffer 的子类有：ByteBuffer、IntBuffer、 CharBuffer、 LongBuffer、 DoubleBuffer、FloatBuffer、ShortBuffer<h3 id="9-6-4-Selector"><a href="#9-6-4-Selector" class="headerlink" title="9.6.4 Selector"></a>9.6.4 Selector</h3>Selector 类是 NIO 的核心类，Selector 能够==检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理==。这样一来，只是==用一个单线程就可以管理多个通道==，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，并且避免了多线程之间的上下文切换导致的开销。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/18/垃圾回收器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="scope">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/18/垃圾回收器/" itemprop="url">垃圾回收器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-18T22:11:09+08:00">
                2019-07-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="8垃圾回收器"><a href="#8垃圾回收器" class="headerlink" title="8垃圾回收器"></a>8垃圾回收器</h1><p><img src="https://img-blog.csdnimg.cn/20190401113414398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Njb3BlMTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="8-1-Serial-垃圾收集器（单线程、-复制-算法）"><a href="#8-1-Serial-垃圾收集器（单线程、-复制-算法）" class="headerlink" title="8.1 Serial 垃圾收集器（单线程、==复制==算法）"></a>8.1 Serial 垃圾收集器（单线程、==复制==算法）</h2><p>最基本的垃圾回收器。在收集垃圾过程中需要==暂停所有其他的工作线程==，它简单高效，是 java 虚拟机运行在 ==Client== 模式下默认的==新生代==垃圾收集器。</p>
<h2 id="8-2-ParNew-垃圾收集器（Serial-多线程-复制）"><a href="#8-2-ParNew-垃圾收集器（Serial-多线程-复制）" class="headerlink" title="8.2 ParNew 垃圾收集器（Serial+多线程+复制）"></a>8.2 ParNew 垃圾收集器（Serial+多线程+复制）</h2><p>除了多线程外，其他和Serial一样，工作时也需要暂停所有的其他工作线程。很多 java虚拟机运行在 ==Server== 模式下==新生代==的默认垃圾收集器。</p>
<h2 id="8-3Parallel-Scavenge-收集器（多线程复制算法、高效）"><a href="#8-3Parallel-Scavenge-收集器（多线程复制算法、高效）" class="headerlink" title="8.3Parallel Scavenge 收集器（多线程复制算法、高效）"></a>8.3Parallel Scavenge 收集器（多线程复制算法、高效）</h2><p>它重点关注的是程序达到一个==可控制的吞吐量==（Thoughput，CPU 用于运行用户代码的时间/CPU 总消耗时间，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)），高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。==自适应调节策略==也是 ParallelScavenge 收集器与 ParNew 收集器的一个重要区别。 ==新生代==</p>
<h2 id="8-4Serial-Old-收集器（-单线程标记整理-算法-）"><a href="#8-4Serial-Old-收集器（-单线程标记整理-算法-）" class="headerlink" title="8.4Serial Old 收集器（==单线程标记整理==算法 ）"></a>8.4Serial Old 收集器（==单线程标记整理==算法 ）</h2><p>Serial Old 是 Serial 垃圾收集器==年老代==版本，它同样是个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在 ==Client ==默认的 java 虚拟机默认的年老代垃圾收集器。<br>新生代 Serial 与年老代 Serial Old 搭配垃圾收集过程图：<br><img src="https://img-blog.csdnimg.cn/20190401114557410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Njb3BlMTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>新生代 Parallel Scavenge/ParNew 与年老代 Serial Old 搭配垃圾收集过程图：<br><img src="https://img-blog.csdnimg.cn/20190401114710901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Njb3BlMTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="8-5Parallel-Old-收集器（多线程标记整理算法）"><a href="#8-5Parallel-Old-收集器（多线程标记整理算法）" class="headerlink" title="8.5Parallel Old 收集器（多线程标记整理算法）"></a>8.5Parallel Old 收集器（多线程标记整理算法）</h2><p>Parallel Old 正是为了在年老代同样提供==吞吐量优先==的垃圾收集器，<br>新生代 Parallel Scavenge 和年老代 Parallel Old 收集器搭配运行过程图：<br><img src="https://img-blog.csdnimg.cn/20190401120022495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Njb3BlMTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="8-6CMS-收集器（-多线程标记清除算法-）"><a href="#8-6CMS-收集器（-多线程标记清除算法-）" class="headerlink" title="8.6CMS 收集器（==多线程标记清除算法==）"></a>8.6CMS 收集器（==多线程标记清除算法==）</h2><p>Concurrent mark sweep(CMS)收集器是一种年老代垃圾收集器，其最主要目标是==获取最短垃圾回收停顿时间==，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。==最短的垃圾收集停顿时间==可以为交互比较高的程序提高用户体验。<br>1.初始标记<br>只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要==暂停==所有的工作线程。</p>
<ol start="2">
<li>并发标记<br>进行 GC Roots 跟踪的过程，和用户线程一起工作，==不需要暂停==工作线程。</li>
<li>重新标记<br>为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要==暂停==所有的工作线程。</li>
<li>并发清除<br>清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。由于==耗时最长的并发标记和并发清除==过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS 收集器的内存回收和用户线程是==一起==并发地执行。<br>CMS 收集器工作过程：<br><img src="https://img-blog.csdnimg.cn/2019040112041518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Njb3BlMTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="8-7-G1-收集器"><a href="#8-7-G1-收集器" class="headerlink" title="8.7 G1 收集器"></a>8.7 G1 收集器</h2>Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器，G1 收集器两个最突出的改进是：</li>
<li>==基于标记-整理算法，不产生内存碎片==。</li>
<li>可以==非常精确控制停顿时间==，在不牺牲吞吐量前提下，实现低停顿垃圾回收。G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。==区域划分==和==优先级区域回收机制==，确保 G1 收集器可以在有限时间获得==最高的垃圾收集效率==。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/18/JAVA四种引用类型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="scope">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/18/JAVA四种引用类型/" itemprop="url">JAVA四种引用类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-18T22:10:33+08:00">
                2019-07-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="7JAVA四种引用类型"><a href="#7JAVA四种引用类型" class="headerlink" title="7JAVA四种引用类型"></a>7JAVA四种引用类型</h1><h2 id="7-1强引用"><a href="#7-1强引用" class="headerlink" title="7.1强引用"></a>7.1强引用</h2><p>Java 中最常见的就是强引用，把==一个对象赋给一个引用变量==，这个引用变量就是一个强引用。==当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收==。因此强引用是造成 ==Java 内存泄漏的主要原因之一==。</p>
<h2 id="7-2软引用（描述有用但非必需的对象）解决OOM问题"><a href="#7-2软引用（描述有用但非必需的对象）解决OOM问题" class="headerlink" title="7.2软引用（描述有用但非必需的对象）解决OOM问题"></a>7.2软引用（描述有用但非必需的对象）解决OOM问题</h2><p>软引用需要用 ==SoftReference== 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，==当系统内存空间不足时它会被回收==。软引用通常用在对内存敏感的程序中。 </p>
<h2 id="7-3-弱引用（描述非必需对象）解决OOM问题"><a href="#7-3-弱引用（描述非必需对象）解决OOM问题" class="headerlink" title="7.3 弱引用（描述非必需对象）解决OOM问题"></a>7.3 弱引用（描述非必需对象）解决OOM问题</h2><p>弱引用需要用 ==WeakReference== 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，==总会回收该对象占用的内存==</p>
<h2 id="7-4虚引用"><a href="#7-4虚引用" class="headerlink" title="7.4虚引用"></a>7.4虚引用</h2><p>虚引用需要== PhantomReference== 类来实现，它不能单独使用，==必须和引用队列联合使用==。虚引用的主要作用是==跟踪对象被垃圾回收的状态==。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/18/垃圾回收算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="scope">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/18/垃圾回收算法/" itemprop="url">垃圾回收算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-18T22:09:48+08:00">
                2019-07-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="6-垃圾回收和算法"><a href="#6-垃圾回收和算法" class="headerlink" title="6 垃圾回收和算法"></a>6 垃圾回收和算法</h1><p><img src="https://img-blog.csdnimg.cn/20190328105721624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Njb3BlMTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="6-1如何判断垃圾"><a href="#6-1如何判断垃圾" class="headerlink" title="6.1如何判断垃圾"></a>6.1如何判断垃圾</h2><p>1.引用计数法（循环引用）<br>即一个对象如果没有任何与之关联的引用，即他们的==引用计数都为 0，==则说明对象不太可能再被用到，那么这个对象就是可回收对象。<br>2.可达性分析（根搜索算法）<br>如果在“GC roots”和一个对象之间==没有可达路径==，则称该对象是不可达的。==要注意的是，不可达对象不等价于可回收对象==，不可达对象变为可回收对象==至少要经过两次标记过程。两次标记后仍然是可回收对象==，则将面临回收。</p>
<h2 id="6-2标记清除算法（Mark-Sweep）"><a href="#6-2标记清除算法（Mark-Sweep）" class="headerlink" title="6.2标记清除算法（Mark-Sweep）"></a>6.2标记清除算法（Mark-Sweep）</h2><p>最基础的垃圾回收算法，分为两个阶段，==标注和清除==。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。<br>==最大问题-内存碎片化严重==<br><img src="https://img-blog.csdnimg.cn/20190328102901435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Njb3BlMTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="6-3复制算法"><a href="#6-3复制算法" class="headerlink" title="6.3复制算法"></a>6.3复制算法</h2><p>按内存容量将内存划分为==等大小的两块。====每次只使用其中一块==，当这一块内存满后将==尚存活的对象复制到另一块==上去，把已使用的内存清掉，<br>最大的问题是==可用内存被压缩到了原本的一半==。且存活对象增多的话，==Copying 算法的效率会大大降低==。</p>
<h2 id="6-4标记整理算法-Mark-Compact"><a href="#6-4标记整理算法-Mark-Compact" class="headerlink" title="6.4标记整理算法(Mark-Compact)"></a>6.4标记整理算法(Mark-Compact)</h2><p>标记阶段和 Mark-Sweep 算法相同，标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。<br><img src="https://img-blog.csdnimg.cn/20190328104010685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Njb3BlMTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="6-5分代收集算法"><a href="#6-5分代收集算法" class="headerlink" title="6.5分代收集算法"></a>6.5分代收集算法</h2><p>分代收集法是==目前大部分 JVM 所采用的方法==，其核心思想是==根据对象存活的不同生命周期将内存划分为不同的域==，一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(Young Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。</p>
<h3 id="1-新生代和复制算法"><a href="#1-新生代和复制算法" class="headerlink" title="1.新生代和复制算法"></a>1.新生代和复制算法</h3><p>一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，==将该两块空间中还存活的对象复制到另一块 Survivor 空间中==。</p>
<h3 id="2-老年代与标记整理算法-Mark-Compact"><a href="#2-老年代与标记整理算法-Mark-Compact" class="headerlink" title="2.老年代与标记整理算法(Mark-Compact)"></a>2.老年代与标记整理算法(Mark-Compact)</h3><ol>
<li>JAVA 虚拟机提到过的处于方法区的永生代(Permanet Generation)，它用来存储 class 类，常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。</li>
<li>对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space(Survivor 目前存放对象的那一块)，少数情况会直接分配到老生代（==对象特别大的时候==）。</li>
<li>当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC，进行 GC 后，Eden Space 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 From Space 进行清理。</li>
<li>如果 To Space 无法足够存储某个对象，则将这个对象存储到老生代。</li>
<li>在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。</li>
<li>当对象在 Survivor 区躲过一次 GC 后，==其年龄就会+1==。默认情况下年龄到达 15 的对象会被移到老生代中。<h2 id="6-6分区收集算法"><a href="#6-6分区收集算法" class="headerlink" title="6.6分区收集算法"></a>6.6分区收集算法</h2>分区算法则==将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收. ==这样做的好处是可以控制一次回收多少个小区间 , 根据目标停顿时间, 每次合理地回收若干个小区间(而不是整个堆), 从而减少一次 GC 所产生的停顿。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/18/JVM运行时内存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="scope">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/18/JVM运行时内存/" itemprop="url">JVM运行时内存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-18T22:09:08+08:00">
                2019-07-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="5-JVM运行时内存"><a href="#5-JVM运行时内存" class="headerlink" title="5 JVM运行时内存"></a>5 JVM运行时内存</h1><h2 id="5-1新生代"><a href="#5-1新生代" class="headerlink" title="5.1新生代"></a>5.1新生代</h2><p>用来存放新生的对象。占据堆的1/3空间，频繁创建对象所以频繁触发GC。新生代又分为 Eden 区、ServivorFrom、ServivorTo 三个区。<br>Eden区。Java==新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。8/10.<br>ServivorFrom上一次 GC 的幸存者，作为这一次 GC 的被扫描者。<br>ServivorTo保留了一次 MinorGC 过程中的幸存者。<br>MinorGC 的过程（==复制-&gt;清空-&gt;互换==） MinorGC采用复制算法。<br>1：eden、servicorFrom 复制到 ServicorTo，年龄+1<br>2：清空 eden、servicorFrom<br>3：ServicorTo 和 ServicorFrom 互换</p>
<h2 id="5-2老年代"><a href="#5-2老年代" class="headerlink" title="5.2老年代"></a>5.2老年代</h2><p>主要存放应用程序中生命周期长的内存对象。老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。<br>MajorGC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC 的耗时比较长，因为要扫描再回收。当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常。</p>
<h2 id="5-3永久代"><a href="#5-3永久代" class="headerlink" title="5.3永久代"></a>5.3永久代</h2><p>指内存的永久保存区域，主要存放== Class 和 Meta（元数据）==的信息,Class 在被加载的时候被放入永久区域，它和和存放实例的区域不同,GC 不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。<br>永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。元空间的本质和永久代类似，元空间与永久代之间最大的区别在于：==元空间并不在虚拟机中，而是使用本地内存==。因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 native memory, 字符串池和类的静态变量放入 java 堆中，这样可以加载多少类的元数据就不再由MaxPermSize 控制, 而由系统的实际可用空间来控制。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/18/JVM内存区域/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="scope">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/18/JVM内存区域/" itemprop="url">JVM内存区域</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-18T22:07:43+08:00">
                2019-07-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="4JVM内存区域"><a href="#4JVM内存区域" class="headerlink" title="4JVM内存区域"></a>4JVM内存区域</h1><p>线程私有区域（程序计数器、虚拟机栈、本地方法区） 生命周期与线程相同，依赖用户线程的启动/结束而创建/销毁。<br>线程共享区域（JAVA堆、方法区） 随虚拟机的启动/关闭 而创建/销毁。<br>直接内存并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用。<br><img src="https://img-blog.csdnimg.cn/20190327110651833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Njb3BlMTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="4-1程序计数器"><a href="#4-1程序计数器" class="headerlink" title="4.1程序计数器"></a>4.1程序计数器</h2><p>一块较小的内存空间，是当前线程==所执行字节码==的行号计数器。每一条线程都有一个计数器。</p>
<h2 id="4-2-虚拟机栈"><a href="#4-2-虚拟机栈" class="headerlink" title="4.2 虚拟机栈"></a>4.2 虚拟机栈</h2><p>是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）<br>用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成<br>的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 栈帧随着方法创建而创建，随着方法结束而结束。</p>
<h2 id="4-3-本地方法区"><a href="#4-3-本地方法区" class="headerlink" title="4.3 本地方法区"></a>4.3 本地方法区</h2><p>和虚拟机栈类似，虚拟机栈为JAVA方法服务，本地方法栈为Native（本地）方法服务。</p>
<h2 id="4-4堆（新生代和老年代）"><a href="#4-4堆（新生代和老年代）" class="headerlink" title="4.4堆（新生代和老年代）"></a>4.4堆（新生代和老年代）</h2><p>是被线程共享的一块内存区域，创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。<img src="https://img-blog.csdnimg.cn/20190327110741631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Njb3BlMTE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="4-5-方法区（永久代）"><a href="#4-5-方法区（永久代）" class="headerlink" title="4.5 方法区（永久代）"></a>4.5 方法区（永久代）</h2><p>即我们常说的永久代(Permanent Generation), 用于存储被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。HotSpot VM把GC分代收集扩展至方法区, 即使用Java堆的永久代来实现方法区, 这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存, 而不必为方法区开发专门的内存管理器(永久带的内存回收的主要目标是针对==常量池的回收和类型的卸载,== 因此收益一般很小)。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/18/JVM基本概念/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="scope">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/18/JVM基本概念/" itemprop="url">JVM基本概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-18T22:06:36+08:00">
                2019-07-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>@<a href="JVM">TOC</a></p>
<h1 id="1基本概念"><a href="#1基本概念" class="headerlink" title="1基本概念"></a>1基本概念</h1><p>1.JVM包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收、堆、一个存储方法域。</p>
<h1 id="2运行过程"><a href="#2运行过程" class="headerlink" title="2运行过程"></a>2运行过程</h1><p>1.Java源文件-编译器-字节码文件（.class）-JVM中的解释器-机器码。<br>每一种平台解释器不同，实现的虚拟机相同，所以JAVA可以跨平台。一个程序开始运行，启动一个虚拟机，多个程序运行，启动多个虚拟机，程序关闭，虚拟机消亡。每个虚拟机之间的数据不能共享。</p>
<h1 id="3线程"><a href="#3线程" class="headerlink" title="3线程"></a>3线程</h1><p>JVM允许一个应用并发多个线程。<br>JAVA线程准备好后，会创建操作系统原生线程。JAVA线程结束，原生线程被回收。操作系统负责调度线程并分配到可用CPU上。原生线程初始化完毕，会调用JAVA的run()方法。线程结束，会释放原生线程和JAVA线程的所有资源。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">scope</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">scope</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
